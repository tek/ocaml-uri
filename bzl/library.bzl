load(
    "@obazl_rules_ocaml//ocaml:rules.bzl",
    "ocaml_library",
    "ocaml_module",
    "ocaml_signature",
    "ppx_library",
    "ppx_module",
)
load("@bazel_skylib//rules:copy_file.bzl", "copy_file")

# When a module implementation (.ml) is generated by a rule, it will be written to the build directory.
# In that case, the linker will complain about inconsistent interfaces because the .mli isn't located in the same
# directory.
# This rule copies the interface file into the build directory as well.
# It uses the subdirectory `__obazl` because this path is hardcoded in the ppx machinery.
def copy_interface(name, out):
    copy_file(
        name = name + "_mli",
        src = name + ".mli",
        out = "__obazl/" + out + ".mli",
    )

def sig_module(name, struct, sig, sig_src, ppx = False, **kw):
    module = ppx_module if ppx else ocaml_module
    ocaml_signature(name = sig, src = sig_src, **kw)
    module(name = name, struct = struct, sig = sig, **kw)

def lib(modules, name = "lib", deps_opam = [], deps = [], ppx = False, **kw):
    library = ppx_library if ppx else ocaml_library
    for (mod_name, struct, sig, sig_src) in modules:
        sig_module(mod_name, struct, sig, sig_src, deps_opam = deps_opam, deps = deps, ppx = ppx)
    module_targets = [n for (n, m, s, ss) in modules]
    library(
        name = name,
        modules = module_targets,
        visibility = ["//visibility:public"],
        **kw
    )

def simple_lib(modules, **kw):
    targets = [(m, m + ".ml", m + "_sig", m + ".mli") for m in modules]
    return lib(targets, **kw)
